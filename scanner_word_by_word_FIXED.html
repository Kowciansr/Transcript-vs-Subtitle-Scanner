<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transcript vs Subtitle Scanner - Balanced</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>
    <style>
        :root { 
            --primary: #2563eb; 
            --vtt-color: #f97316; 
            --txt-color: #3b82f6; 
            --bg: #f8fafc; 
            --success: #166534; 
            --danger: #dc2626;
        }
        body { 
            font-family: 'Segoe UI', system-ui, sans-serif; 
            background: var(--bg); 
            padding: 20px; 
            color: #1e293b; 
        }
        .container { 
            max-width: 1600px; 
            margin: 0 auto; 
            background: white; 
            padding: 30px; 
            border-radius: 12px; 
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1); 
        }
        
        h1 { font-size: 1.8rem; margin-bottom: 8px; color: #0f172a; }
        .subtitle { color: #64748b; margin-bottom: 25px; font-size: 0.95rem; }
        
        .setup-grid { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 20px; 
            margin: 20px 0; 
        }
        .card { 
            border: 1px solid #e2e8f0; 
            padding: 15px; 
            border-radius: 8px; 
            background: #fff; 
        }
        
        .diff-wrapper { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 15px; 
            margin-top: 25px; 
        }
        .pane-container { 
            border: 1px solid #e2e8f0; 
            border-radius: 8px; 
            overflow: hidden; 
            background: white; 
        }
        .pane-header { 
            background: #f1f5f9; 
            padding: 12px; 
            font-weight: bold; 
            text-align: center; 
            border-bottom: 1px solid #e2e8f0; 
            color: #475569; 
        }
        .diff-pane { 
            height: 400px; 
            overflow: auto; 
            padding: 20px; 
            white-space: pre-wrap; 
            font-family: 'Consolas', monospace; 
            font-size: 0.85rem; 
            line-height: 1.8; 
            background: #fafafa;
        }
        
        .double-space-highlight { 
            background: #fef3c7; 
            border-bottom: 2px solid #f59e0b; 
            padding: 2px 0;
        }
        .mismatch-highlight { 
            background: #fee2e2; 
            color: #991b1b; 
            padding: 2px 4px;
            border-radius: 3px;
        }
        .vtt-meta { 
            color: #94a3b8; 
            font-style: italic; 
        }

        .scorecard { 
            background: #eff6ff; 
            border: 2px solid #bfdbfe; 
            padding: 15px; 
            border-radius: 8px; 
            margin: 25px 0; 
            text-align: center; 
        }
        .score-val { 
            font-size: 2.2rem; 
            font-weight: bold; 
            color: var(--primary); 
        }

        .section-header { 
            margin-top: 35px; 
            padding: 12px; 
            font-weight: bold; 
            color: white; 
            border-radius: 8px 8px 0 0; 
            display: flex; 
            justify-content: space-between; 
        }
        .header-danger { background: var(--danger); }
        .header-warning { background: #f59e0b; }
        
        .category-group { 
            border: 1px solid #e2e8f0; 
            background: #fff; 
            margin-bottom: 0px; 
            border-top: none; 
        }
        
        .row { 
            padding: 15px 20px; 
            border-bottom: 1px solid #f1f5f9; 
            font-size: 0.95rem; 
        }
        .row:last-child { border-bottom: none; }
        
        .issue-number {
            display: inline-block;
            background: #3b82f6;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .file-label {
            font-weight: 600;
            color: #0f172a;
            margin-top: 8px;
            display: block;
        }
        
        .sentence-box { 
            background: #f8fafc;
            padding: 12px; 
            margin: 8px 0;
            border-left: 4px solid #cbd5e1; 
            font-family: 'Consolas', monospace;
            font-size: 0.9rem;
            border-radius: 4px;
        }
        
        .sentence-box.transcript { border-left-color: var(--txt-color); }
        .sentence-box.subtitle { border-left-color: var(--vtt-color); }
        
        .timestamp {
            display: inline-block;
            background: #475569;
            color: white;
            padding: 3px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-family: 'Consolas', monospace;
            margin-left: 10px;
        }
        
        .success-msg { 
            padding: 25px; 
            text-align: center; 
            color: var(--success); 
            font-weight: bold; 
            background: #f0fdf4; 
            border: 1px dashed var(--success); 
            border-radius: 0 0 8px 8px; 
            border-top: none; 
        }
        
        .btn-group { 
            display: flex; 
            gap: 10px; 
            margin-top: 10px; 
        }
        button { 
            flex: 1; 
            padding: 18px; 
            border-radius: 8px; 
            cursor: pointer; 
            font-weight: bold; 
            border: none; 
        }
        .primary-btn { background: var(--primary); color: white; }
        .secondary-btn { background: #64748b; color: white; }
    </style>
</head>
<body>

<div class="container">
    <h1>üìã Transcript vs Subtitle Scanner</h1>
    <p class="subtitle">Detects real differences while handling VTT segment splits</p>
    
    <div class="setup-grid">
        <div class="card"><strong>1. Transcript (.txt) - Source of Truth</strong><input type="file" id="transFile" accept=".txt"></div>
        <div class="card"><strong>2. Subtitle (.vtt) - To Compare</strong><input type="file" id="subFile" accept=".vtt"></div>
    </div>

    <div class="btn-group">
        <button id="runBtn" class="primary-btn" onclick="process()" disabled>Initializing Scanner...</button>
        <button id="dlBtn" class="secondary-btn" onclick="downloadReport()" style="display:none;">Download Report</button>
    </div>
    
    <div id="auditOutput" style="display:none;">
        <div class="diff-wrapper">
            <div class="pane-container">
                <div class="pane-header">üìù Transcript (Double Spaces Highlighted)</div>
                <div id="paneTxt" class="diff-pane"></div>
            </div>
            <div class="pane-container">
                <div class="pane-header">üé¨ Subtitle (Mismatches Highlighted)</div>
                <div id="paneSub" class="diff-pane"></div>
            </div>
        </div>
        <div id="scoreArea"></div>
        <div id="listArea"></div>
    </div>
</div>

<script>
    let pyodide; 
    let lastRes = null;
    
    async function init() { 
        pyodide = await loadPyodide(); 
        document.getElementById('runBtn').innerText = "Run Scan"; 
        document.getElementById('runBtn').disabled = false; 
    }
    init();

    async function process() {
        const subF = document.getElementById('subFile').files[0];
        const transF = document.getElementById('transFile').files[0];
        if(!subF || !transF) return alert("Please select both files.");
        
        window.data_sub = await subF.text();
        window.data_trans = await transF.text();

        const pythonCode = `
import re
import difflib

def run():
    transcript = """${window.data_trans.replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"""
    subtitle = """${window.data_sub.replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"""
    
    # ========================================
    # DOUBLE SPACE DETECTION
    # ========================================
    def find_double_spaces_in_transcript(text):
        double_space_lines = []
        lines = text.split('\\n')
        
        for i, line in enumerate(lines, 1):
            if '  ' in line:
                double_space_lines.append({
                    'line_num': i,
                    'text': line,
                    'count': line.count('  ')
                })
        return double_space_lines
    
    def build_transcript_html_with_highlights(text):
        lines = text.split('\\n')
        html_lines = []
        
        for line in lines:
            if '  ' in line:
                highlighted = line.replace('  ', '<span class="double-space-highlight">  </span>')
                html_lines.append(highlighted)
            else:
                html_lines.append(line)
        
        return '<br>'.join(html_lines)
    
    # ========================================
    # CLEAN TRANSCRIPT
    # ========================================
    def clean_transcript(text):
        cleaned = re.sub(r'  +', ' ', text)
        cleaned = cleaned.replace('\\n', ' ')
        cleaned = re.sub(r' +', ' ', cleaned)
        return cleaned.strip()
    
    # ========================================
    # PARSE VTT AND GET FULL TEXT
    # ========================================
    def parse_vtt_segments_with_timestamps(vtt_text):
        """Parse VTT keeping individual segments with timestamps"""
        segments = []
        lines = vtt_text.split('\\n')
        current_time = "00:00:00"
        
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            
            if not line or line == "WEBVTT" or line.isdigit():
                i += 1
                continue
            
            if '-->' in line:
                time_match = re.search(r'(\\d{2}:\\d{2}:\\d{2})', line)
                if time_match:
                    current_time = time_match.group(1)
                i += 1
                continue
            
            if line:
                segments.append({'time': current_time, 'text': line})
            
            i += 1
        
        return segments
    
    def get_full_vtt_text(vtt_segments):
        """Concatenate all VTT segments into full text"""
        all_text = ' '.join([seg['text'] for seg in vtt_segments])
        all_text = re.sub(r' +', ' ', all_text)
        return all_text.strip()
    
    # ========================================
    # WORD-BY-WORD COMPARISON
    # This is the key: compare word by word to find actual differences
    # ========================================
    def compare_word_by_word(trans_text, vtt_text, vtt_segments):
        """
        Compare transcript and subtitle word by word.
        Returns list of differences with context.
        """
        # Split into words
        trans_words = trans_text.split()
        vtt_words = vtt_text.split()
        
        # Use difflib to find differences
        matcher = difflib.SequenceMatcher(None, trans_words, vtt_words)
        
        differences = []
        
        for tag, i1, i2, j1, j2 in matcher.get_opcodes():
            if tag == 'equal':
                # Words match, skip
                continue
            
            elif tag == 'replace':
                # Words are different
                trans_snippet = ' '.join(trans_words[max(0, i1-5):min(len(trans_words), i2+5)])
                vtt_snippet = ' '.join(vtt_words[max(0, j1-5):min(len(vtt_words), j2+5)])
                
                # Find timestamp for this VTT section
                timestamp = find_timestamp_for_words(vtt_words[j1:j2], vtt_segments)
                
                differences.append({
                    'type': 'modified',
                    'transcript': trans_snippet,
                    'subtitle': vtt_snippet,
                    'timestamp': timestamp,
                    'trans_changed': ' '.join(trans_words[i1:i2]),
                    'vtt_changed': ' '.join(vtt_words[j1:j2])
                })
            
            elif tag == 'delete':
                # Words only in transcript - find closest VTT context
                trans_snippet = ' '.join(trans_words[max(0, i1-5):min(len(trans_words), i2+5)])
                
                # Find the closest matching VTT context
                vtt_context_start = max(0, j1-5) if j1 < len(vtt_words) else max(0, len(vtt_words)-10)
                vtt_context_end = min(len(vtt_words), j1+5) if j1 < len(vtt_words) else len(vtt_words)
                vtt_snippet = ' '.join(vtt_words[vtt_context_start:vtt_context_end]) if vtt_words else '[Not in subtitle]'
                
                timestamp = find_timestamp_for_words(vtt_words[vtt_context_start:vtt_context_end], vtt_segments) if vtt_words else None
                
                differences.append({
                    'type': 'transcript_only',
                    'transcript': trans_snippet,
                    'subtitle': vtt_snippet,
                    'timestamp': timestamp,
                    'trans_changed': ' '.join(trans_words[i1:i2]),
                    'vtt_changed': None
                })
            
            elif tag == 'insert':
                # Words only in subtitle - find closest transcript context
                vtt_snippet = ' '.join(vtt_words[max(0, j1-5):min(len(vtt_words), j2+5)])
                timestamp = find_timestamp_for_words(vtt_words[j1:j2], vtt_segments)
                
                # Find the closest matching transcript context
                trans_context_start = max(0, i1-5) if i1 < len(trans_words) else max(0, len(trans_words)-10)
                trans_context_end = min(len(trans_words), i1+5) if i1 < len(trans_words) else len(trans_words)
                trans_snippet = ' '.join(trans_words[trans_context_start:trans_context_end]) if trans_words else '[Not in transcript]'
                
                differences.append({
                    'type': 'subtitle_only',
                    'transcript': trans_snippet,
                    'subtitle': vtt_snippet,
                    'timestamp': timestamp,
                    'trans_changed': None,
                    'vtt_changed': ' '.join(vtt_words[j1:j2])
                })
        
        return differences
    
    def find_timestamp_for_words(words, vtt_segments):
        """Find which timestamp segment contains these words"""
        search_text = ' '.join(words).lower()
        
        for seg in vtt_segments:
            if search_text in seg['text'].lower():
                return seg['time']
        
        # Default to first segment's time if not found
        return vtt_segments[0]['time'] if vtt_segments else "00:00:00"
    
    # ========================================
    # FIND DOUBLE SPACES IN VTT
    # ========================================
    def find_double_spaces_in_vtt(vtt_segments):
        double_space_segs = []
        
        for seg in vtt_segments:
            if '  ' in seg['text']:
                double_space_segs.append({
                    'time': seg['time'],
                    'text': seg['text'],
                    'count': seg['text'].count('  ')
                })
        
        return double_space_segs
    
    # ========================================
    # BUILD VTT HTML WITH HIGHLIGHTS
    # ========================================
    def build_vtt_html_with_highlights(vtt_text, differences):
        """Highlight mismatched segments in VTT"""
        lines = vtt_text.split('\\n')
        html_lines = []
        
        # Get all changed VTT words
        changed_words = set()
        for diff in differences:
            if diff['vtt_changed']:
                for word in diff['vtt_changed'].split():
                    changed_words.add(word.lower().strip('.,!?;:'))
        
        for line in lines:
            line_stripped = line.strip()
            
            if line_stripped == "WEBVTT":
                html_lines.append('<span class="vtt-meta">WEBVTT</span>')
                continue
            
            if '-->' in line_stripped:
                html_lines.append(f'<span class="vtt-meta">{line_stripped}</span>')
                continue
            
            if line_stripped.isdigit():
                html_lines.append(f'<span class="vtt-meta">{line_stripped}</span>')
                continue
            
            if not line_stripped:
                html_lines.append('')
                continue
            
            # Check if this line contains any changed words
            has_mismatch = False
            for word in line_stripped.split():
                clean_word = word.lower().strip('.,!?;:')
                if clean_word in changed_words:
                    has_mismatch = True
                    break
            
            if has_mismatch:
                html_lines.append(f'<span class="mismatch-highlight">{line_stripped}</span>')
            else:
                html_lines.append(line_stripped)
        
        return '<br>'.join(html_lines)
    
    # ========================================
    # EXECUTE ALL SCANS
    # ========================================
    
    # Step 1: Double spaces in transcript
    trans_double_spaces = find_double_spaces_in_transcript(transcript)
    trans_html = build_transcript_html_with_highlights(transcript)
    
    # Step 2: Clean transcript
    cleaned_trans = clean_transcript(transcript)
    
    # Step 3: Parse VTT
    vtt_segments = parse_vtt_segments_with_timestamps(subtitle)
    full_vtt_text = get_full_vtt_text(vtt_segments)
    
    # Step 4: Double spaces in VTT
    vtt_double_spaces = find_double_spaces_in_vtt(vtt_segments)
    
    # Step 5: Word-by-word comparison
    differences = compare_word_by_word(cleaned_trans, full_vtt_text, vtt_segments)
    
    # Step 6: Build VTT HTML with highlights
    vtt_html = build_vtt_html_with_highlights(subtitle, differences)
    
    # Calculate match percentage
    total_trans_words = len(cleaned_trans.split())
    total_diff_words = sum(len(d['trans_changed'].split()) if d['trans_changed'] else 0 for d in differences)
    match_percent = round(((total_trans_words - total_diff_words) / total_trans_words * 100)) if total_trans_words > 0 else 100
    
    return {
        "trans_html": trans_html,
        "vtt_html": vtt_html,
        "trans_double_spaces": trans_double_spaces,
        "vtt_double_spaces": vtt_double_spaces,
        "differences": differences,
        "match_percent": match_percent
    }

run()
`;
        
        lastRes = (await pyodide.runPythonAsync(pythonCode)).toJs();
        render();
    }

    function render() {
        document.getElementById('auditOutput').style.display = 'block';
        document.getElementById('dlBtn').style.display = 'inline-block';
        
        document.getElementById('paneTxt').innerHTML = lastRes.get('trans_html');
        document.getElementById('paneSub').innerHTML = lastRes.get('vtt_html');
        
        document.getElementById('scoreArea').innerHTML = `<div class="scorecard"><span class="score-val">${lastRes.get('match_percent')}% Match</span></div>`;
        
        const listArea = document.getElementById('listArea');
        listArea.innerHTML = "";
        
        const transDS = lastRes.get('trans_double_spaces');
        const vttDS = lastRes.get('vtt_double_spaces');
        const differences = lastRes.get('differences');
        
        // Double Spaces in Transcript
        listArea.innerHTML += `<div class="section-header header-warning"><span>‚ö†Ô∏è Double Spaces in Transcript</span><span>Total: ${transDS.length}</span></div>`;
        
        if (transDS.length === 0) {
            listArea.innerHTML += `<div class="success-msg">‚úÖ No double spaces found</div>`;
        } else {
            let html = `<div class="category-group">`;
            transDS.forEach(item => {
                html += `<div class="row">
                    <strong>Line ${item.get('line_num')}</strong> - ${item.get('count')} double space(s)
                    <div class="sentence-box transcript">${item.get('text').replace(/  /g, '‚éµ‚éµ')}</div>
                </div>`;
            });
            listArea.innerHTML += html + `</div>`;
        }
        
        // Double Spaces in Subtitle
        listArea.innerHTML += `<div class="section-header header-warning"><span>‚ö†Ô∏è Double Spaces in Subtitle</span><span>Total: ${vttDS.length}</span></div>`;
        
        if (vttDS.length === 0) {
            listArea.innerHTML += `<div class="success-msg">‚úÖ No double spaces found</div>`;
        } else {
            let html = `<div class="category-group">`;
            vttDS.forEach(item => {
                html += `<div class="row">
                    <strong>Timestamp: ${item.get('time')}</strong> - ${item.get('count')} double space(s)
                    <div class="sentence-box subtitle">${item.get('text').replace(/  /g, '‚éµ‚éµ')}</div>
                </div>`;
            });
            listArea.innerHTML += html + `</div>`;
        }
        
        // Content Differences
        listArea.innerHTML += `<div class="section-header header-danger"><span>üîç Content Differences</span><span>Total: ${differences.length}</span></div>`;
        
        if (differences.length === 0) {
            listArea.innerHTML += `<div class="success-msg">‚úÖ All content matches perfectly</div>`;
        } else {
            let html = `<div class="category-group">`;
            
            differences.forEach((item, idx) => {
                const type = item.get('type');
                const trans = item.get('transcript');
                const sub = item.get('subtitle');
                const timestamp = item.get('timestamp');
                
                html += `<div class="row">
                    <div class="issue-number">Issue ${idx + 1}</div>`;
                
                if (type === 'modified') {
                    html += `
                        <div class="file-label">üìù Transcript:</div>
                        <div class="sentence-box transcript">${trans}</div>
                        
                        <div class="file-label">üé¨ Subtitle: ${timestamp ? '<span class="timestamp">' + timestamp + '</span>' : ''}</div>
                        <div class="sentence-box subtitle">${sub}</div>
                    `;
                } else if (type === 'transcript_only') {
                    html += `
                        <div class="file-label">üìù Transcript:</div>
                        <div class="sentence-box transcript">${trans}</div>
                        
                        <div class="file-label">üé¨ Subtitle: ${timestamp ? '<span class="timestamp">' + timestamp + '</span>' : ''}</div>
                        <div class="sentence-box subtitle">${sub}</div>
                    `;
                } else if (type === 'subtitle_only') {
                    html += `
                        <div class="file-label">üìù Transcript:</div>
                        <div class="sentence-box transcript">${trans}</div>
                        
                        <div class="file-label">üé¨ Subtitle: ${timestamp ? '<span class="timestamp">' + timestamp + '</span>' : ''}</div>
                        <div class="sentence-box subtitle">${sub}</div>
                    `;
                }
                
                html += `</div>`;
            });
            
            listArea.innerHTML += html + `</div>`;
        }
    }

    function downloadReport() {
        let r = `TRANSCRIPT vs SUBTITLE SCAN REPORT\n`;
        r += `Match Score: ${lastRes.get('match_percent')}%\n`;
        r += `Generated: ${new Date().toLocaleString()}\n`;
        r += `${'='.repeat(70)}\n\n`;
        
        const transDS = lastRes.get('trans_double_spaces');
        const vttDS = lastRes.get('vtt_double_spaces');
        const differences = lastRes.get('differences');
        
        r += `DOUBLE SPACES IN TRANSCRIPT (${transDS.length})\n${'-'.repeat(70)}\n\n`;
        if (transDS.length === 0) {
            r += `‚úÖ No double spaces\n\n`;
        } else {
            transDS.forEach(item => {
                r += `Line ${item.get('line_num')}: ${item.get('text')}\n\n`;
            });
        }
        
        r += `\nDOUBLE SPACES IN SUBTITLE (${vttDS.length})\n${'-'.repeat(70)}\n\n`;
        if (vttDS.length === 0) {
            r += `‚úÖ No double spaces\n\n`;
        } else {
            vttDS.forEach(item => {
                r += `${item.get('time')}: ${item.get('text')}\n\n`;
            });
        }
        
        r += `\nCONTENT DIFFERENCES (${differences.length})\n${'-'.repeat(70)}\n\n`;
        if (differences.length === 0) {
            r += `‚úÖ Perfect match\n\n`;
        } else {
            differences.forEach((item, idx) => {
                r += `Issue ${idx + 1}:\n\n`;
                const trans = item.get('transcript');
                const sub = item.get('subtitle');
                const timestamp = item.get('timestamp');
                
                r += `Transcript: ${trans || '[Not in transcript]'}\n`;
                r += `Subtitle: ${sub || '[Not in subtitle]'}${timestamp ? ' (Timeframe: ' + timestamp + ')' : ''}\n\n`;
            });
        }
        
        const blob = new Blob([r], {type: 'text/plain'});
        const a = document.createElement('a'); 
        a.href = URL.createObjectURL(blob); 
        a.download = `Scan_Report_${new Date().toISOString().slice(0,10)}.txt`; 
        a.click();
    }
</script>
</body>
</html>
